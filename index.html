<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ê°œêµ¬ëŸ‰ ì¸¡ì • â€” í†µí•© ì—”ì§„(ì…ìˆ  & ì½”â€“í„±) </title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;display:flex;justify-content:center;align-items:center;padding:20px}
    .container{background:rgba(255,255,255,0.96);border-radius:18px;box-shadow:0 16px 50px rgba(0,0,0,.25);padding:24px;max-width:1200px;width:100%}
    h1{font-size:28px;text-align:center;margin-bottom:18px;color:#333}
    .main{display:flex;gap:24px;flex-wrap:wrap}
    .video-wrap{position:relative;flex:1;min-width:320px;max-width:720px}
    video,canvas{width:100%;height:auto;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.15)}
    #overlay{position:absolute;inset:0}
 
	/* FaceGuide */
	#faceGuide{
	  position:absolute;
	  top:50%;
	  left:50%;
	  transform:translate(-50%,-50%);
	  width:46%;
	  aspect-ratio:400/666;         /* ìœ ì§€: ì›í•˜ëŠ” ê°€ì´ë“œ ë¹„ìœ¨ */
	  border:3px dashed rgba(255,255,255,.55);
	  border-radius:24px;            /* ë‘¥ê·¼ì‚¬ê°í˜• */
	  pointer-events:none;
	  display:flex;
	  align-items:center;
	  justify-content:center;
	  z-index:10
	}
	#faceGuide.active{
	  border-color:#22c55e;
	  animation:pulse 1s infinite
	}

    #guideText{color:#fff;background:rgba(0,0,0,.45);padding:8px 12px;border-radius:8px;font-weight:700}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:.6}}

    .panel{flex:0 0 360px;background:linear-gradient(145deg,#f5f7fa,#c3cfe2);border-radius:12px;padding:18px;box-shadow:0 8px 24px rgba(0,0,0,.1)}
    .section-title{font-weight:500;color:#444;margin:6px 0 10px}
    .kv{display:grid;grid-template-columns:1fr auto;gap:8px;margin-bottom:10px}
    .k{color:#666}
    .v{font-weight:700;color:#5850ec}
    .btns{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    button{flex:1;min-width:110px;padding:10px 14px;border:none;border-radius:10px;cursor:pointer;font-weight:700}
    .p{background:linear-gradient(135deg,#667eea,#764ba2);color:#fff}
    .s{background:#e0e7ff;color:#5850ec}
    .d{background:#fee2e2;color:#b91c1c}
    .msg{margin-top:10px;border-left:4px solid #3b82f6;background:#eff6ff;color:#1e3a8a;padding:10px;border-radius:8px}
    .calib{background:#fff7ed;border:2px dashed #fb923c;color:#7c2d12;border-radius:10px;padding:12px;margin-bottom:12px;text-align:center}
    .calib.done{background:#ecfdf5;border-color:#10b981;color:#065f46}
    .debug{margin-top:8px;padding-top:8px;border-top:1px dashed #94a3b8}
    .badge{display:inline-block;padding:3px 8px;border-radius:999px;font-size:12px;background:#e2e8f0;color:#334155;margin-left:6px}
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ”¬ ê°œêµ¬ëŸ‰ ì¸¡ì • â€” í†µí•© ì—”ì§„(ì…ìˆ  & ì½”â€“í„±)</h1>
    <div id="msg" class="msg">ì¹´ë©”ë¼ ê¶Œí•œì„ ìš”ì²­ ì¤‘ì…ë‹ˆë‹¤â€¦</div>

    <div class="main">
      <div class="video-wrap">
        <video id="video" autoplay playsinline></video>
        <canvas id="overlay"></canvas>
        <div id="faceGuide"><div id="guideText">ì–¼êµ´ì„ ì—¬ê¸°ì— ë§ì¶°ì£¼ì„¸ìš”</div></div>
      </div>

      <div class="panel">
        <div id="calibBox" class="calib">
          <div class="section-title">ğŸ“ ë³´ì • ìƒíƒœ</div>
          <div id="calibInfo">ì•ˆê²½(ì •ë©´ í­ 140mm)ì„ ì–¼êµ´ì— ë§ì¶”ê³  <b>ë³´ì • ì‹œì‘</b>ì„ ëˆ„ë¥´ì„¸ìš”.</div>
          <button id="btnCalib" class="p" style="margin-top:10px">ë³´ì • ì‹œì‘</button>
          <button id="btnStart" class="p" disabled>ì¸¡ì • ì‹œì‘</button>
          <button id="btnStop" class="s" disabled>ì¸¡ì • ì¤‘ì§€</button>
          <button id="btnReset" class="d">ë¦¬ì…‹</button>
        </div>

        <div class="section-title">ğŸ“Š ì‹¤ì‹œê°„ ì¸¡ì •</div>
        <div class="kv"><div class="k">í†µí•© ê°œêµ¬ëŸ‰</div><div class="v" id="vFusion">0.0 mm</div></div>
        <div class="kv"><div class="k">ì…ìˆ  ê¸°ë°˜</div><div class="v" id="vLips">0.0 mm</div></div>
        <div class="kv"><div class="k">ì½”â€“í„± ê¸°ë°˜</div><div class="v" id="vNC">0.0 mm</div></div>
         <div class="kv"><div class="k">ê°€ì¤‘ì¹˜</div><div class="v" id="vW">lip 50% / nc 50%</div></div> 
        <div class="kv"><div class="k">ì–¼êµ´ ê¸°ìš¸ê¸°(roll)</div><div class="v" id="vRoll">0.0Â°</div></div>
        <div class="kv"><div class="k">ìµœëŒ€ ê°œêµ¬ëŸ‰(í†µí•©)</div><div class="v" id="vMax">0.0 mm</div></div>

        <div class="btns">

        </div>
        <div class="debug">
          <span class="k">ì—”ì§„:</span>
          <span id="engineBadge" class="badge">-</span>
        </div>
      </div>
    </div>
  </div>

  <!-- MediaPipe FaceMesh -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>

  <script>
  // ===== ì „ì—­ ìƒíƒœ =====
  let faceMesh, camera;
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const ctx = overlay.getContext('2d');

  let isCalibrating=false, isCalibrated=false, isMeasuring=false;
  let pixelsPerMM = 1; // ì£¼ ìŠ¤ì¼€ì¼(ì•ˆê²½ ë³´ì •)
  let maxOpeningMM = 0;

  const IDX = { NOSE_TIP:4, CHIN_TIP:152, LIP_UP_IN:13, LIP_LO_IN:14, MID_BROW:10, L_EYE:33, R_EYE:263 };

  // í†µí•© ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì €ì¥ì†Œ
  const calib = { pixelsPerMM:1, rest_lips:null, rest_nc:null, emaOpening:null };
  const EMA_ALPHA = 0.35;
  const confState = { lipHist:[], ncHist:[], maxHist:5 };

  // ===== ìœ í‹¸ =====
  const $ = id=>document.getElementById(id);
  const pxToMM = px => px / (calib.pixelsPerMM||1);
  const v = (x0,y0,x1,y1)=>({x:x1-x0,y:y1-y0});
  const dot=(a,b)=>a.x*b.x+a.y*b.y; const norm=a=>Math.hypot(a.x,a.y)||1; const unit=a=>{const n=norm(a);return {x:a.x/n,y:a.y/n}};

  function faceVerticalAxis(lm,W,H){
    const a=v(lm[IDX.MID_BROW].x*W,lm[IDX.MID_BROW].y*H,lm[IDX.CHIN_TIP].x*W,lm[IDX.CHIN_TIP].y*H);
    return unit(a);
  }
  function estimatePixelsPerMMByIPD(lm,W,H){
    const le=lm[IDX.L_EYE], re=lm[IDX.R_EYE];
    const ipd_px = Math.hypot((le.x-re.x)*W,(le.y-re.y)*H);
    const IPD_MM_AVG=63; // í‰ê· ì¹˜(ë°±ì—…ìš©)
    return ipd_px / IPD_MM_AVG;
  }

  function measureByLips(lm,W,H){
    const up=lm[IDX.LIP_UP_IN], lo=lm[IDX.LIP_LO_IN];
    return Math.abs((up.y-lo.y)*H); // px
  }
  function measureByNoseChin(lm,W,H){
    const nose=lm[IDX.NOSE_TIP], chin=lm[IDX.CHIN_TIP];
    const axis = faceVerticalAxis(lm,W,H);
    const nc = v(nose.x*W,nose.y*H,chin.x*W,chin.y*H);
    return dot(nc,axis); // px(ì„¸ë¡œ ì„±ë¶„)
  }

  function rollingStability(arr){
    if(arr.length<3) return 1.0;
    const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
    const sd = Math.sqrt(arr.reduce((s,x)=>s+(x-mean)*(x-mean),0)/arr.length)||1;
    return Math.max(0.3, Math.min(1.0, 1.0 - (sd/(mean+1e-3))*0.6));
  }
  function computeWeights(lip_px,nc_px,rollDeg){
    confState.lipHist.push(lip_px); if(confState.lipHist.length>confState.maxHist) confState.lipHist.shift();
    confState.ncHist.push(nc_px);   if(confState.ncHist.length>confState.maxHist)  confState.ncHist.shift();
    let w_lip=rollingStability(confState.lipHist);
    let w_nc =rollingStability(confState.ncHist);
    if(Math.abs(rollDeg)>15) w_lip *= 0.7; // ê¸°ìš¸ë©´ ì…ìˆ  ì‹ ë¢°ë„ í•˜í–¥
    const s=w_lip+w_nc||1; return {w_lip:w_lip/s,w_nc:w_nc/s};
  }

  function unifiedMeasure(lm,W,H){
    // ìŠ¤ì¼€ì¼ í™•ë³´
    let ppm = calib.pixelsPerMM || pixelsPerMM || 1;
    if(!ppm || ppm<=0){
      const alt = estimatePixelsPerMMByIPD(lm,W,H);
      if(alt>0) ppm = alt;
    }
    calib.pixelsPerMM = ppm;

    // ë‘ ë°©ì‹
    const lip_px = measureByLips(lm,W,H);
    const nc_px  = measureByNoseChin(lm,W,H);

    if(calib.rest_lips==null) calib.rest_lips = lip_px;
    if(calib.rest_nc==null)   calib.rest_nc   = nc_px;

    const delta_lip_mm = pxToMM(Math.max(0, lip_px - calib.rest_lips));
    const delta_nc_mm  = pxToMM(Math.max(0, nc_px  - calib.rest_nc));

    const axis = faceVerticalAxis(lm,W,H);
    const rollDeg = Math.atan2(axis.x,axis.y)*180/Math.PI;

    const {w_lip,w_nc} = computeWeights(lip_px,nc_px,rollDeg);
    const fusedNow = w_lip*delta_lip_mm + w_nc*delta_nc_mm;

    calib.emaOpening = (calib.emaOpening==null)? fusedNow : (EMA_ALPHA*fusedNow + (1-EMA_ALPHA)*calib.emaOpening);
    const which = (w_lip>=w_nc)? 'lips-major' : 'nose-chin-major';

    return { openingMM: calib.emaOpening, raw:{lip_mm:delta_lip_mm,nc_mm:delta_nc_mm,fused_now:fusedNow}, weights:{w_lip,w_nc}, pose:{rollDeg}, whichUsed:which };
  }

  // ===== FaceGuide íŒì • =====
	function isInFaceGuide(lm, W, H){
	  const nose = lm[IDX.NOSE_TIP], chin = lm[IDX.CHIN_TIP], mid = lm[IDX.MID_BROW];
	  const faceCx = (nose.x*W + chin.x*W)/2, faceCy = (nose.y*H + chin.y*H)/2;

	  const guideW = W * 0.70, guideH = H * 0.70;
	  const halfW = guideW / 2, halfH = guideH / 2;
	  const r = Math.min(guideW, guideH) * 0.08; // ëª¨ì„œë¦¬ ë°˜ì§€ë¦„ ë¹„ìœ¨

	  const dx = faceCx - W/2, dy = faceCy - H/2;

	  // ì¶• ê¸°ì¤€ ì½”ì–´ ì‚¬ê°í˜• (ëª¨ì„œë¦¬ ë¼ìš´ë“œ ì œì™¸ ì˜ì—­)
	  const coreW = halfW - r, coreH = halfH - r;

	  let inGuide = false;

	  if (Math.abs(dx) <= coreW && Math.abs(dy) <= halfH) inGuide = true;       // ì¢Œìš° ì½”ì–´
	  else if (Math.abs(dy) <= coreH && Math.abs(dx) <= halfW) inGuide = true;  // ìƒí•˜ ì½”ì–´
	  else {
		// ëª¨ì„œë¦¬ 4ê°œ ì¤‘ í•´ë‹¹ ì› ë‚´ë¶€ íŒì •
		const cornerX = (dx > 0 ? coreW : -coreW);
		const cornerY = (dy > 0 ? coreH : -coreH);
		const cx = cornerX, cy = cornerY;
		inGuide = ((dx - cx)**2 + (dy - cy)**2) <= r**2;
	  }

	  const len = Math.hypot((mid.x-chin.x)*W,(mid.y-chin.y)*H);
	  const sizeOK = len > H*0.25 && len < H*0.55;

	  return inGuide && sizeOK;
	}


  // ===== ë©”ì‹œì§€/DOM =====
  function setMsg(t, ok){ const el=$('msg'); el.textContent=t; el.style.background= ok?'#ecfdf5':'#eff6ff'; el.style.borderLeftColor = ok?'#10b981':'#3b82f6'; }
  function setEngineBadge(s){ $('engineBadge').textContent = s; }

  // ===== ìº¡ì³ + 10mm ê²©ì =====
  function drawGrid10mm(ctx,W,H,ppm){
    const step = 10 * (ppm||1); // 10mm â†’ px
    if(!isFinite(step) || step<=0) return;
    ctx.save();
    ctx.strokeStyle='rgba(0,0,0,0.3)';
    ctx.lineWidth=1;
    for(let x=0;x<W;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<H;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    // ì¤‘ì•™ì¶• ê°•ì¡°
    ctx.strokeStyle='rgba(255,0,0,0.45)'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(W/2,0); ctx.lineTo(W/2,H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,H/2); ctx.lineTo(W,H/2); ctx.stroke();
    ctx.restore();
  }

	function captureFrame(label, unifiedValue){
	  const W = video.videoWidth || overlay.width;
	  const H = video.videoHeight || overlay.height;
	  if(!W || !H) {
		console.warn("ìº”ë²„ìŠ¤ í¬ê¸° ì—†ìŒ, ìº¡ì²˜ ì¤‘ë‹¨");
		return;
	  }

	  const cap = document.createElement('canvas');
	  cap.width = W;
	  cap.height = H;
	  const cctx = cap.getContext('2d');

	  // 1) ë¹„ë””ì˜¤ í”„ë ˆì„
	  try {
		cctx.drawImage(video, 0, 0, W, H);
	  } catch(e) {
		cctx.fillStyle = '#000';
		cctx.fillRect(0, 0, W, H);
	  }

	  // 2) ì˜¤ë²„ë ˆì´(ëœë“œë§ˆí¬ ë“±)
	  cctx.drawImage(overlay, 0, 0, W, H);
		// âœ… faceGuide ì¶”ê°€
		drawFaceGuideOnCapture(cctx, W, H);
	  // 3) 10mm ê²©ì ì¶”ê°€
	  drawGrid10mm(cctx, W, H, calib.pixelsPerMM || pixelsPerMM || 1);

	  // 4) í—¤ë” í…ìŠ¤íŠ¸
	  cctx.fillStyle = 'rgba(0,0,0,0.55)';
	  cctx.fillRect(10, 10, 320, 70);
	  cctx.fillStyle = '#fff';
	  cctx.font = 'bold 16px Segoe UI, Arial';
	  cctx.fillText(`Capture: ${label}`, 20, 32);
	  cctx.fillText(new Date().toLocaleString(), 20, 52);

	  // 5) âœ… í†µí•© ê°œêµ¬ëŸ‰ ì¶”ê°€ (ì•ˆì „ ì²˜ë¦¬)
	  if (unifiedValue !== undefined && !isNaN(unifiedValue)) {
		cctx.fillText(`í†µí•© ê°œêµ¬ëŸ‰: ${unifiedValue.toFixed(1)} mm`, 20, 72);
	  }

	  // 6) ì €ì¥
	  const a = document.createElement('a');
	  a.href = cap.toDataURL('image/png');
	  a.download = `jaw_${label}_${new Date().toISOString().replace(/[:.]/g,'-')}.png`;
	  a.click();
	}

  // ===== ì´ˆê¸°í™” =====
  async function init(){
    faceMesh = new FaceMesh({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${f}` });
    faceMesh.setOptions({ maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:.5, minTrackingConfidence:.5 });
    faceMesh.onResults(onResults);

    try{
      const stream = await navigator.mediaDevices.getUserMedia({ video:{width:640,height:480,facingMode:'user'} });
      video.srcObject = stream;
      camera = new Camera(video,{ onFrame: async()=>{ await faceMesh.send({image:video}); }, width:640, height:480 });
      await camera.start();
      setMsg('ì¹´ë©”ë¼ê°€ ì„±ê³µì ìœ¼ë¡œ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤!', true);
      setTimeout(()=>$('msg').style.display='none', 2000);
    }catch(e){ setMsg('ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨: '+e.message, false); }

    overlay.width = 640; overlay.height = 480;

    $('btnCalib').onclick = startCalibration;
    $('btnStart').onclick = ()=>{
      if(isCalibrated){
        isMeasuring=true; $('btnStart').disabled=true; $('btnStop').disabled=false; maxOpeningMM=0;
        captureFrame('start',maxOpeningMM);
        setMsg('ì¸¡ì •ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì…ì„ ì²œì²œíˆ ë²Œë ¤ì£¼ì„¸ìš”.', false); setTimeout(()=>$('msg').style.display='none',1500);
      }
    };
	$('btnStop').onclick = ()=>{
	  if(isMeasuring){
		isMeasuring = false;
		$('btnStart').disabled = false;
		$('btnStop').disabled = true;

		// âœ… í†µí•© ê°œêµ¬ëŸ‰ ì „ë‹¬
		captureFrame('stop', maxOpeningMM);

		setMsg('ì¸¡ì •ì„ ì¢…ë£Œí–ˆìŠµë‹ˆë‹¤. ìµœëŒ€ê°’ì´ ê¸°ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.', true);
		setTimeout(()=>$('msg').style.display='none',1500);
	  }
	};

    $('btnReset').onclick = resetAll;
  }

  function drawLandmarks(lm){
    ctx.clearRect(0,0,overlay.width,overlay.height);
    const keys=[IDX.MID_BROW,IDX.NOSE_TIP,IDX.CHIN_TIP,IDX.LIP_UP_IN,IDX.LIP_LO_IN];
    keys.forEach(i=>{
      const x=lm[i].x*overlay.width, y=lm[i].y*overlay.height;
      ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fillStyle='#ff3b3b'; ctx.fill();
    });
    const p=[IDX.MID_BROW,IDX.NOSE_TIP,IDX.CHIN_TIP].map(i=>({x:lm[i].x*overlay.width,y:lm[i].y*overlay.height}));
    ctx.beginPath(); ctx.moveTo(p[0].x,p[0].y); ctx.lineTo(p[1].x,p[1].y); ctx.lineTo(p[2].x,p[2].y); ctx.strokeStyle='#ffe600'; ctx.lineWidth=2; ctx.stroke();
  }

  // ===== ë³´ì • ë£¨í‹´ =====
  function startCalibration(){
    if(isCalibrating) return;
    isCalibrating=true; $('btnCalib').disabled=true; setMsg('ë³´ì • ì¤‘â€¦ ì…ì„ ë‹¤ë¬¼ê³  ì •ì§€í•´ì£¼ì„¸ìš”(ì•½ 3ì´ˆ).', false);

    const samples=[];
    const sampler = setInterval(()=>{ if(lastLM){
      const W=overlay.width,H=overlay.height;
      samples.push({ lip:measureByLips(lastLM,W,H), nc:measureByNoseChin(lastLM,W,H) });
    } }, 50);

    setTimeout(()=>{
      clearInterval(sampler);
      if(samples.length){
        const avg = arr=>arr.reduce((a,b)=>a+b,0)/arr.length;
        calib.rest_lips = avg(samples.map(s=>s.lip));
        calib.rest_nc   = avg(samples.map(s=>s.nc));
        calib.emaOpening=0;
      }
      // ì•ˆê²½ 140mm ê¸°ì¤€ ìŠ¤ì¼€ì¼ (ì˜ˆì‹œ: 240px â‰ˆ 140mm)
      pixelsPerMM = 240/140; calib.pixelsPerMM = pixelsPerMM;

      isCalibrated=true; isCalibrating=false;
      $('calibBox').classList.add('done');
      $('calibInfo').innerHTML = `âœ… ë³´ì • ì™„ë£Œ!<br>1 mm = ${(calib.pixelsPerMM).toFixed(2)} px (ì•ˆê²½ ê¸°ì¤€)`;
      $('btnStart').disabled=false; $('btnCalib').disabled=true;
      setMsg('ë³´ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì¸¡ì •ì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!', true);
      setTimeout(()=>$('msg').style.display='none', 1500);
    }, 3000);
  }

  function resetAll(){
    isCalibrating=false; isCalibrated=false; isMeasuring=false;
    pixelsPerMM=1; maxOpeningMM=0; calib.pixelsPerMM=1; calib.rest_lips=null; calib.rest_nc=null; calib.emaOpening=null;
    confState.lipHist.length=0; confState.ncHist.length=0;
    $('vFusion').textContent='0.0 mm'; $('vLips').textContent='0.0 mm'; $('vNC').textContent='0.0 mm'; $('vW').textContent='lip 50% / nc 50%'; $('vRoll').textContent='0.0Â°'; $('vMax').textContent='0.0 mm'; setEngineBadge('-');
    $('btnStart').disabled=true; $('btnStop').disabled=true; $('btnCalib').disabled=false;
    $('calibBox').classList.remove('done'); $('calibInfo').innerHTML = 'ì•ˆê²½(ì •ë©´ í­ 140mm)ì„ ì–¼êµ´ì— ë§ì¶”ê³  <b>ë³´ì • ì‹œì‘</b>ì„ ëˆ„ë¥´ì„¸ìš”.';
    setMsg('ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.', true); setTimeout(()=>$('msg').style.display='none', 1200);
  }

  // ===== ê²°ê³¼/UI ì—…ë°ì´íŠ¸ =====
  function updateUI(res){
    $('vFusion').textContent = `${res.openingMM.toFixed(1)} mm`;
    $('vLips').textContent   = `${res.raw.lip_mm.toFixed(1)} mm`;
    $('vNC').textContent     = `${res.raw.nc_mm.toFixed(1)} mm`;
    $('vW').textContent      = `lip ${(res.weights.w_lip*100).toFixed(0)}% / nc ${(res.weights.w_nc*100).toFixed(0)}%`;
    $('vRoll').textContent   = `${res.pose.rollDeg.toFixed(1)}Â°`;
    setEngineBadge(res.whichUsed);
    if(res.openingMM>maxOpeningMM){ maxOpeningMM = res.openingMM; $('vMax').textContent = `${maxOpeningMM.toFixed(1)} mm`; }
  }

  // ===== FaceMesh ê²°ê³¼ ì²˜ë¦¬ =====
  let lastLM=null;
  function onResults(results){
    overlay.width = video.videoWidth; overlay.height = video.videoHeight;
    ctx.clearRect(0,0,overlay.width,overlay.height);

    if(results.multiFaceLandmarks && results.multiFaceLandmarks[0]){
      const lm = results.multiFaceLandmarks[0]; lastLM=lm; drawLandmarks(lm);

      // FaceGuide í™œì„±/ë¹„í™œì„± í† ê¸€
      const inGuide = isInFaceGuide(lm, overlay.width, overlay.height);
      const guide = $('faceGuide');
      if(inGuide){ guide.classList.add('active'); $('guideText').textContent='ì •ë ¬ ì™„ë£Œ!'; }
      else { guide.classList.remove('active'); $('guideText').textContent='ì–¼êµ´ì„ ì—¬ê¸°ì— ë§ì¶°ì£¼ì„¸ìš”'; }

      if(isMeasuring && isCalibrated){
        const res = unifiedMeasure(lm, overlay.width, overlay.height);
        updateUI(res);
      }
    } else {
      $('faceGuide').classList.remove('active'); $('guideText').textContent='ì–¼êµ´ì„ ì—¬ê¸°ì— ë§ì¶°ì£¼ì„¸ìš”';
    }
  }
	function drawRoundedRect(ctx, x, y, w, h, r) {
	  const radius = Math.min(r, Math.min(w, h) / 2);
	  ctx.beginPath();
	  ctx.moveTo(x + radius, y);
	  ctx.lineTo(x + w - radius, y);
	  ctx.arcTo(x + w, y, x + w, y + radius, radius);
	  ctx.lineTo(x + w, y + h - radius);
	  ctx.arcTo(x + w, y + h, x + w - radius, y + h, radius);
	  ctx.lineTo(x + radius, y + h);
	  ctx.arcTo(x, y + h, x, y + h - radius, radius);
	  ctx.lineTo(x, y + radius);
	  ctx.arcTo(x, y, x + radius, y, radius);
	  ctx.closePath();
	}

	function drawFaceGuideOnCapture(ctx, W, H){
	  const guideW = W * 0.46;
	  const guideH = H * 0.92;
	  const cx = W/2, cy = H/2;
	  const x = cx - guideW/2, y = cy - guideH/2;

	  ctx.save();
	  ctx.strokeStyle = 'rgba(255,255,255,0.55)';
	  ctx.lineWidth = 3;
	  ctx.setLineDash([10,6]);

	  // ë‘¥ê·¼ì‚¬ê°í˜• (ëª¨ì„œë¦¬ ë°˜ì§€ë¦„ 24px)
	  drawRoundedRect(ctx, x, y, guideW, guideH, 32);
	  ctx.stroke();
	  ctx.restore();
	}


  // ì‹œì‘
  window.addEventListener('load', init);
  </script>
</body>
</html>
