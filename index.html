<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì–¼êµ´ ì›€ì§ì„ ì •ë°€ ë¶„ì„ ì‹œìŠ¤í…œ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .main-content {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .video-section {
            position: relative;
            flex: 1;
            min-width: 300px;
            max-width: 640px;
        }

        #videoElement, #outputCanvas {
            width: 100%;
            height: auto;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        #outputCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .control-panel {
            flex: 0 0 350px;
            background: linear-gradient(145deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .status-section {
            margin-bottom: 25px;
        }

        .status-title {
            font-size: 1.2em;
            color: #555;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .status-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            transition: transform 0.2s;
        }

        .status-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .status-label {
            font-weight: 500;
            color: #666;
        }

        .status-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #667eea;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .btn {
            flex: 1;
            min-width: 100px;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #e0e7ff;
            color: #667eea;
        }

        .btn-secondary:hover {
            background: #c7d2fe;
        }

        .btn-danger {
            background: #fee2e2;
            color: #dc2626;
        }

        .btn-danger:hover {
            background: #fecaca;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .calibration-section {
            background: #fef3c7;
            border: 2px dashed #f59e0b;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .calibration-section.completed {
            background: #d1fae5;
            border-color: #10b981;
        }

        .calibration-info {
            color: #92400e;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .calibration-section.completed .calibration-info {
            color: #065f46;
        }

        .message-box {
            background: #eff6ff;
            border-left: 4px solid #3b82f6;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(-20px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .control-panel {
                flex: 1;
                width: 100%;
            }
            
            h1 {
                font-size: 1.5em;
            }
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”¬ ì–¼êµ´ ì›€ì§ì„ ì •ë°€ ë¶„ì„ ì‹œìŠ¤í…œ</h1>
        
        <div id="messageBox" class="message-box">
            <span id="messageText">ì¹´ë©”ë¼ ê¶Œí•œì„ ìš”ì²­ ì¤‘ì…ë‹ˆë‹¤...</span>
        </div>

        <div class="main-content">
            <div class="video-section">
                <video id="videoElement" autoplay playsinline></video>
                <canvas id="outputCanvas"></canvas>
            </div>

            <div class="control-panel">
                <div class="calibration-section" id="calibrationSection">
                    <div class="status-title">ğŸ“ ë³´ì • ìƒíƒœ</div>
                    <div class="calibration-info">
                        ì‹ ìš©ì¹´ë“œë‚˜ ì£¼ë¯¼ë“±ë¡ì¦(ê°€ë¡œ 85.6mm)ì„<br>
                        ì´ë§ˆì— ëŒ€ê³  'ë³´ì • ì‹œì‘' ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”
                    </div>
                    <button id="calibrateBtn" class="btn btn-primary" style="margin-top: 10px;">ë³´ì • ì‹œì‘</button>
                </div>

                <div class="status-section">
                    <div class="status-title">ğŸ“Š ì‹¤ì‹œê°„ ì¸¡ì •ê°’</div>
                    
                    <div class="status-item">
                        <span class="status-label">ìµœëŒ€ ê°œêµ¬ëŸ‰</span>
                        <span class="status-value" id="maxOpeningValue">0.0 mm</span>
                    </div>
                    
                    <div class="status-item">
                        <span class="status-label">í„± í¸ì´</span>
                        <span class="status-value" id="jawDeviationValue">ì¤‘ì•™</span>
                    </div>
                    
                    <div class="status-item">
                        <span class="status-label">ì–¼êµ´ ê¸°ìš¸ê¸°</span>
                        <span class="status-value" id="headTiltValue">0.0Â°</span>
                    </div>
                </div>

                <div class="button-group">
                    <button id="startMeasureBtn" class="btn btn-primary" disabled>ì¸¡ì • ì‹œì‘</button>
                    <button id="stopMeasureBtn" class="btn btn-secondary" disabled>ì¸¡ì • ì¤‘ì§€</button>
                    <button id="resetBtn" class="btn btn-danger">ë¦¬ì…‹</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
    
    <script>
        // ì „ì—­ ë³€ìˆ˜
        let faceMesh;
        let camera;
        let isCalibrated = false;
        let pixelsPerMM = 1;
        let isMeasuring = false;
        let maxOpeningRecord = 0;
        let maxDeviationRecord = { value: 0, direction: 'Center' };
        let calibrationPoints = [];
        let isCalibrating = false;

        // ëœë“œë§ˆí¬ ì¸ë±ìŠ¤ ì •ì˜
        const LANDMARKS = {
            FOREHEAD_CENTER: 10,  // ë¯¸ê°„
            NOSE_TIP: 4,          // ì½”ë
            CHIN_TIP: 152,        // í„± ë
            UPPER_LIP_INNER: 13,  // ìœ—ì…ìˆ  ì•ˆìª½
            LOWER_LIP_INNER: 14   // ì•„ë«ì…ìˆ  ì•ˆìª½
        };

        // DOM ìš”ì†Œ
        const videoElement = document.getElementById('videoElement');
        const canvasElement = document.getElementById('outputCanvas');
        const canvasCtx = canvasElement.getContext('2d');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        
        const calibrateBtn = document.getElementById('calibrateBtn');
        const startMeasureBtn = document.getElementById('startMeasureBtn');
        const stopMeasureBtn = document.getElementById('stopMeasureBtn');
        const resetBtn = document.getElementById('resetBtn');
        
        const maxOpeningValue = document.getElementById('maxOpeningValue');
        const jawDeviationValue = document.getElementById('jawDeviationValue');
        const headTiltValue = document.getElementById('headTiltValue');
        const calibrationSection = document.getElementById('calibrationSection');
 
		
		let trajectoryPoints = [];

		function drawTrajectory() {
			if (trajectoryPoints.length < 2) return;

			canvasCtx.beginPath();
			canvasCtx.moveTo(trajectoryPoints[0].x, trajectoryPoints[0].y);
			for (let i = 1; i < trajectoryPoints.length; i++) {
				canvasCtx.lineTo(trajectoryPoints[i].x, trajectoryPoints[i].y);
			}
			canvasCtx.strokeStyle = 'rgba(255, 165, 0, 0.8)'; // ì£¼í™©ìƒ‰
			canvasCtx.lineWidth = 2;
			canvasCtx.stroke();
		}

        // ì´ˆê¸°í™”
        function initializeFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}`;
                }
            });

            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMesh.onResults(onResults);

            camera = new Camera(videoElement, {
                onFrame: async () => {
                    await faceMesh.send({ image: videoElement });
                },
                width: 640,
                height: 480
            });

            camera.start().then(() => {
                updateMessage('ì¹´ë©”ë¼ê°€ ì„±ê³µì ìœ¼ë¡œ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
                setTimeout(() => messageBox.style.display = 'none', 3000);
            }).catch(err => {
                updateMessage('ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨: ' + err.message, 'error');
            });
        }

        // Face Mesh ê²°ê³¼ ì²˜ë¦¬
        function onResults(results) {
            // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            
            // ìº”ë²„ìŠ¤ í´ë¦¬ì–´
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks[0]) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // ëœë“œë§ˆí¬ ê·¸ë¦¬ê¸°
                drawLandmarks(landmarks);
                
                // ì¤‘ì‹¬ì„  ê·¸ë¦¬ê¸°
                drawCenterLine(landmarks);
                
                // ë³´ì • ëª¨ë“œ
                if (isCalibrating) {
                    handleCalibration(landmarks);
                }
                
                // ì¸¡ì • ëª¨ë“œ
                if (isMeasuring && isCalibrated) {
                    measureMetrics(landmarks);
                }
                
                // ì–¼êµ´ ê¸°ìš¸ê¸° ê³„ì‚° (í•­ìƒ í‘œì‹œ)
                calculateHeadTilt(landmarks);
            }
            
            canvasCtx.restore();
        }

        // ëœë“œë§ˆí¬ ê·¸ë¦¬ê¸°
        function drawLandmarks(landmarks) {
            // ëª¨ë“  ëœë“œë§ˆí¬ ì  ê·¸ë¦¬ê¸°
            landmarks.forEach((landmark, i) => {
                const x = landmark.x * canvasElement.width;
                const y = landmark.y * canvasElement.height;
                
                canvasCtx.beginPath();
                canvasCtx.arc(x, y, 2, 0, 2 * Math.PI);
                
                // ì£¼ìš” ëœë“œë§ˆí¬ëŠ” ë‹¤ë¥¸ ìƒ‰ìƒìœ¼ë¡œ í‘œì‹œ
                if (i === LANDMARKS.FOREHEAD_CENTER || 
                    i === LANDMARKS.NOSE_TIP || 
                    i === LANDMARKS.CHIN_TIP ||
                    i === LANDMARKS.UPPER_LIP_INNER ||
                    i === LANDMARKS.LOWER_LIP_INNER) {
                    canvasCtx.fillStyle = '#ff0000';
                    canvasCtx.strokeStyle = '#ff0000';
                } else {
                    canvasCtx.fillStyle = '#00ff00';
                    canvasCtx.strokeStyle = '#00ff00';
                }
                
                canvasCtx.fill();
            });
        }

        // ì¤‘ì‹¬ì„  ê·¸ë¦¬ê¸°
        function drawCenterLine(landmarks) {
            const forehead = landmarks[LANDMARKS.FOREHEAD_CENTER];
            const noseTip = landmarks[LANDMARKS.NOSE_TIP];
            const chinTip = landmarks[LANDMARKS.CHIN_TIP];
            
            canvasCtx.beginPath();
            canvasCtx.moveTo(forehead.x * canvasElement.width, forehead.y * canvasElement.height);
            canvasCtx.lineTo(noseTip.x * canvasElement.width, noseTip.y * canvasElement.height);
            canvasCtx.lineTo(chinTip.x * canvasElement.width, chinTip.y * canvasElement.height);
            canvasCtx.strokeStyle = '#ffff00';
            canvasCtx.lineWidth = 2;
            canvasCtx.stroke();
        }

        // ë³´ì • ì²˜ë¦¬
        function handleCalibration(landmarks) {
            // ì´ë§ˆ ì˜ì—­ì˜ ëœë“œë§ˆí¬ë“¤ì„ ì‚¬ìš©í•˜ì—¬ ì¹´ë“œ í¬ê¸° ê°ì§€
            // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì»´í“¨í„° ë¹„ì „ ê¸°ë²•ìœ¼ë¡œ ì¹´ë“œ ëª¨ì„œë¦¬ë¥¼ ê°ì§€í•´ì•¼ í•¨
            // ì—¬ê¸°ì„œëŠ” ê°„ë‹¨í•œ ì‹œë®¬ë ˆì´ì…˜
            
            canvasCtx.fillStyle = 'rgba(255, 255, 0, 0.3)';
            canvasCtx.fillRect(
                canvasElement.width * 0.3, 
                canvasElement.height * 0.1,
                canvasElement.width * 0.4,
                canvasElement.height * 0.15
            );
            
            canvasCtx.strokeStyle = '#ffff00';
            canvasCtx.lineWidth = 3;
            canvasCtx.strokeRect(
                canvasElement.width * 0.3, 
                canvasElement.height * 0.1,
                canvasElement.width * 0.4,
                canvasElement.height * 0.15
            );
            
            canvasCtx.fillStyle = '#000';
            canvasCtx.font = '20px Arial';
            canvasCtx.fillText('ì¹´ë“œë¥¼ ì´ ì˜ì—­ì— ë§ì¶°ì£¼ì„¸ìš”', canvasElement.width * 0.35, canvasElement.height * 0.05);
        }

        // ì¸¡ì • ë©”íŠ¸ë¦­ ê³„ì‚°
        function measureMetrics(landmarks) { 
	
			
            // 1. ìµœëŒ€ ê°œêµ¬ëŸ‰ ê³„ì‚°
            const upperLip = landmarks[LANDMARKS.UPPER_LIP_INNER];
            const lowerLip = landmarks[LANDMARKS.LOWER_LIP_INNER];
            
            const openingPixels = Math.abs(upperLip.y - lowerLip.y) * canvasElement.height;
            const openingMM = openingPixels / pixelsPerMM-2;
            
			// 1. ì‹¤ì‹œê°„ ê°œêµ¬ëŸ‰ í‘œì‹œ
			maxOpeningValue.textContent = `${openingMM.toFixed(1)} mm`;

			// 2. ìµœëŒ€ê°’ ê°±ì‹ 
			if (openingMM > maxOpeningRecord) {
				maxOpeningRecord = openingMM;
			}

            
            // 3. í„± í¸ì´ ê³„ì‚°
            const forehead = landmarks[LANDMARKS.FOREHEAD_CENTER];
            const noseTip = landmarks[LANDMARKS.NOSE_TIP];
            const chinTip = landmarks[LANDMARKS.CHIN_TIP];
            
            // ì¤‘ì‹¬ì„ ì˜ x ì¢Œí‘œ ê³„ì‚° (ë¯¸ê°„ê³¼ ì½”ëì˜ í‰ê· )
            const centerLineX = (forehead.x + noseTip.x) / 2;
            
            // í„± ëì˜ í¸ì´ ê³„ì‚°
            const deviationPixels = (chinTip.x - centerLineX) * canvasElement.width;
            const deviationMM = Math.abs(deviationPixels) / pixelsPerMM;
			// 4. í„±ëì¢Œí‘œê¸°ë¡
			const chinX = chinTip.x * canvasElement.width;
			const chinY = chinTip.y * canvasElement.height;
			trajectoryPoints.push({ x: chinX, y: chinY });

			// ê¶¤ì  ê·¸ë¦¬ê¸°
			drawTrajectory();
            if (deviationMM > maxDeviationRecord.value) {
                maxDeviationRecord.value = deviationMM;
                maxDeviationRecord.direction = deviationPixels > 0 ? 'Right' : 'Left';
                
                const directionKor = deviationPixels > 0 ? 'Rt.' : 'Lt.';
                jawDeviationValue.textContent = `${directionKor} ${deviationMM.toFixed(1)} mm`;
            }
            
            // ì‹œê°ì  í”¼ë“œë°±
            drawMeasurementLines(upperLip, lowerLip, chinTip, centerLineX);
        }

        // ì¸¡ì •ì„  ê·¸ë¦¬ê¸°
        function drawMeasurementLines(upperLip, lowerLip, chinTip, centerLineX) {
            // ê°œêµ¬ëŸ‰ ì„ 
            canvasCtx.beginPath();
            canvasCtx.moveTo(upperLip.x * canvasElement.width, upperLip.y * canvasElement.height);
            canvasCtx.lineTo(lowerLip.x * canvasElement.width, lowerLip.y * canvasElement.height);
            canvasCtx.strokeStyle = '#00ffff';
            canvasCtx.lineWidth = 3;
            canvasCtx.stroke();
            
            // í¸ì´ ì„ 
            canvasCtx.beginPath();
            canvasCtx.moveTo(centerLineX * canvasElement.width, chinTip.y * canvasElement.height);
            canvasCtx.lineTo(chinTip.x * canvasElement.width, chinTip.y * canvasElement.height);
            canvasCtx.strokeStyle = '#ff00ff';
            canvasCtx.lineWidth = 3;
            canvasCtx.stroke();
        }

        // ì–¼êµ´ ê¸°ìš¸ê¸° ê³„ì‚°
        function calculateHeadTilt(landmarks) {
            const forehead = landmarks[LANDMARKS.FOREHEAD_CENTER];
            const chinTip = landmarks[LANDMARKS.CHIN_TIP];
            
            const deltaX = chinTip.x - forehead.x;
            const deltaY = chinTip.y - forehead.y;
            
            let angle = Math.atan2(deltaX, deltaY) * (180 / Math.PI);
            
            headTiltValue.textContent = `${angle.toFixed(1)}Â°`;
        }

        // ë©”ì‹œì§€ ì—…ë°ì´íŠ¸
        function updateMessage(text, type = 'info') {
            messageText.textContent = text;
            messageBox.style.display = 'block';
            messageBox.className = 'message-box';
            
            if (type === 'error') {
                messageBox.style.borderColor = '#ef4444';
                messageBox.style.background = '#fee2e2';
            } else if (type === 'success') {
                messageBox.style.borderColor = '#10b981';
                messageBox.style.background = '#d1fae5';
            }
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        calibrateBtn.addEventListener('click', () => {
            if (!isCalibrating) {
                isCalibrating = true;
                calibrateBtn.textContent = 'ë³´ì • ì™„ë£Œ';
                updateMessage('ì¹´ë“œë¥¼ ì´ë§ˆì— ëŒ€ê³  í™”ë©´ì˜ ì‚¬ê°í˜• ì˜ì—­ì— ë§ì¶°ì£¼ì„¸ìš”', 'info');
                
                // 3ì´ˆ í›„ ìë™ ë³´ì • ì™„ë£Œ (ì‹¤ì œë¡œëŠ” ì¹´ë“œ ê°ì§€ ì•Œê³ ë¦¬ì¦˜ í•„ìš”)
                setTimeout(() => {
                    // ì‹œë®¬ë ˆì´ì…˜: 85.6mm = ~240 pixels (ì˜ˆì‹œê°’)
                    pixelsPerMM = 240 / 85.6;
                    isCalibrated = true;
                    isCalibrating = false;
                    
                    calibrationSection.classList.add('completed');
                    calibrationSection.querySelector('.calibration-info').innerHTML = 
                        `âœ… ë³´ì • ì™„ë£Œ!<br>1mm = ${pixelsPerMM.toFixed(2)} pixels`;
                    
                    startMeasureBtn.disabled = false;
                    calibrateBtn.disabled = true;
                    
                    updateMessage('ë³´ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì¸¡ì •ì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!', 'success');
                    setTimeout(() => messageBox.style.display = 'none', 3000);
                }, 3000);
            }
        });

        startMeasureBtn.addEventListener('click', () => {
            if (isCalibrated && !isMeasuring) {
                isMeasuring = true;
                startMeasureBtn.disabled = true;
                stopMeasureBtn.disabled = false;
                // ê¶¤ì ì´ˆê¸°í™”
				trajectoryPoints = [];

                // ê¸°ë¡ ì´ˆê¸°í™”
                maxOpeningRecord = 0;
                maxDeviationRecord = { value: 0, direction: 'Center' };
                
                updateMessage('ì¸¡ì •ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì…ì„ ì²œì²œíˆ ë²Œë ¤ì£¼ì„¸ìš”.', 'info');
                setTimeout(() => messageBox.style.display = 'none', 3000);
            }
        });

		stopMeasureBtn.addEventListener('click', () => {
		  if (isMeasuring) {
			isMeasuring = false;
			startMeasureBtn.disabled = false;
			stopMeasureBtn.disabled = true;

			const resultData = {
			  timestamp: new Date().toISOString(),
			  measurements: {
				maxOpening_mm: parseFloat(maxOpeningRecord.toFixed(1)),
				jawDeviation_mm: parseFloat(maxDeviationRecord.value.toFixed(1)),
				jawDeviation_direction: maxDeviationRecord.direction
			  },
			  calibration: { pixelsPerMM: parseFloat(pixelsPerMM.toFixed(2)) }
			};

			console.log('ì¸¡ì • ê²°ê³¼:', JSON.stringify(resultData, null, 2));
			updateMessage('ì¸¡ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ê²°ê³¼ê°€ ì½˜ì†”ì— ì¶œë ¥ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');

			// í™”ë©´ ìŠ¤ëƒ…ìƒ· ì €ì¥ (ìµœëŒ€ê°œêµ¬ëŸ‰/í„±í¸ì´íŒì • í¬í•¨)
			// í˜„ì¬ DOM í‘œì‹œê°’ì„ ì‚¬ìš©í•˜ë¯€ë¡œ update ì§í›„ì— í˜¸ì¶œ
			requestAnimationFrame(() => captureSnapshot());
		  }
		});

		stopMeasureBtn.addEventListener('click', () => {
			if (isMeasuring) {
				isMeasuring = false;
				startMeasureBtn.disabled = false;
				stopMeasureBtn.disabled = true;

				// ìµœì¢… íŒ¨í„´ ë¶„ì„
				analyzePattern();

				const resultData = {
					timestamp: new Date().toISOString(),
					measurements: {
						maxOpening_mm: parseFloat(maxOpeningRecord.toFixed(1)),
						jawDeviation_mm: parseFloat(maxDeviationRecord.value.toFixed(1)),
						jawDeviation_direction: maxDeviationRecord.direction
					},
					calibration: { pixelsPerMM: parseFloat(pixelsPerMM.toFixed(2)) }
				};

				console.log('ì¸¡ì • ê²°ê³¼:', JSON.stringify(resultData, null, 2));
				updateMessage('ì¸¡ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ê²°ê³¼ê°€ ì½˜ì†”ì— ì¶œë ¥ë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');

				requestAnimationFrame(() => captureSnapshot());
			}
		});

		function analyzePattern() {
			const threshold = 2.0; // mm
			let pattern = 'Normal';
			let patternKo = 'ì •ìƒ';

			if (maxDeviationRecord.value >= threshold) {
				if (Math.abs(maxDeviationRecord.value - 0) >= threshold) {
					pattern = 'Deflection';
					patternKo = 'êµ´ì ˆ';
				} else {
					pattern = 'Deviation';
					patternKo = 'í¸ì°¨';
				}
			}

			// jawDeviationValueì— ìµœì¢… íŒì • í‘œì‹œ
			jawDeviationValue.textContent = `${patternKo} (${pattern})`;

			// í•„ìš”í•˜ë‹¤ë©´ ìƒ‰ìƒ í´ë˜ìŠ¤ ì ìš©
			jawDeviationValue.className = 'status-value';
			if (pattern === 'Normal') {
				jawDeviationValue.classList.add('pattern-normal');
			} else if (pattern === 'Deviation') {
				jawDeviationValue.classList.add('pattern-deviation');
			} else {
				jawDeviationValue.classList.add('pattern-deflection');
			}
		}


		// ìŠ¤ëƒ…ìƒ· ìƒì„± ë° ë‹¤ìš´ë¡œë“œ
		function captureSnapshot() {
		  // ë¹„ë””ì˜¤/ìº”ë²„ìŠ¤ í¬ê¸° ê¸°ì¤€
		  const width = videoElement.videoWidth || canvasElement.width;
		  const height = videoElement.videoHeight || canvasElement.height;
		  if (!width || !height) {
			updateMessage('ìŠ¤ëƒ…ìƒ·ì„ ë§Œë“¤ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¹„ë””ì˜¤ ì´ˆê¸°í™” ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”.', 'error');
			return;
		  }

		  // ì˜¤í”„ìŠ¤í¬ë¦° ìº”ë²„ìŠ¤ ìƒì„±
		  const snapCanvas = document.createElement('canvas');
		  snapCanvas.width = width;
		  snapCanvas.height = height;
		  const ctx = snapCanvas.getContext('2d');

		  // 1) ë¹„ë””ì˜¤ í”„ë ˆì„ ê·¸ë¦¬ê¸°
		  try {
			ctx.drawImage(videoElement, 0, 0, width, height);
		  } catch (e) {
			// ë¹„ë””ì˜¤ ê·¸ë¦¬ê¸° ì‹¤íŒ¨ ì‹œ ë°°ê²½ ì²˜ë¦¬
			ctx.fillStyle = '#000';
			ctx.fillRect(0, 0, width, height);
		  }

		  // 2) ë¶„ì„ ì˜¤ë²„ë ˆì´ ìº”ë²„ìŠ¤ í•©ì„± (í˜„ì¬ ê·¸ë ¤ì§„ ëœë“œë§ˆí¬/ì„  ë“±)
		  ctx.drawImage(canvasElement, 0, 0, width, height);

		  // 3) ì¸¡ì • í…ìŠ¤íŠ¸ ì˜¤ë²„ë ˆì´ (ìµœëŒ€ê°œêµ¬ëŸ‰, í„±í¸ì´íŒì •, í•„ìš”ì‹œ ë¨¸ë¦¬ ê¸°ìš¸ê¸°)
		  const maxOpeningText = maxOpeningValue.textContent;      // e.g., "43.2 mm"
		  const jawText = jawDeviationValue.textContent;           // e.g., "Rt. 2.5 mm" ë˜ëŠ” "ì¤‘ì•™"
		  const headTiltText = headTiltValue.textContent;          // e.g., "1.2Â°"

		  // ì •ë³´ ë°•ìŠ¤ ìŠ¤íƒ€ì¼
		  const pad = 14;
		  const boxW = Math.min(360, Math.round(width * 0.45));
		  const boxH = 110;
		  const boxX = width - boxW - 20;
		  const boxY = 20;

		  // ë°˜íˆ¬ëª… ë°•ìŠ¤
		  ctx.fillStyle = 'rgba(0,0,0,0.55)';
		  ctx.roundRect?.(boxX, boxY, boxW, boxH, 10);
		  if (!ctx.roundRect) {
			// ë¼ìš´ë“œ ì§€ì› ì•ˆë˜ë©´ ì¼ë°˜ ì‚¬ê°í˜•
			ctx.fillRect(boxX, boxY, boxW, boxH);
		  } else {
			ctx.fill();
		  }

		  // í…ìŠ¤íŠ¸
		  ctx.fillStyle = '#fff';
		  ctx.font = 'bold 18px Segoe UI, Arial, sans-serif';
		  ctx.fillText('ì¸¡ì • ìš”ì•½', boxX + pad, boxY + pad + 6);

		  ctx.font = '16px Segoe UI, Arial, sans-serif';
		  const line1 = `ìµœëŒ€ê°œêµ¬ëŸ‰: ${maxOpeningText}`;
		  const line2 = `í„±í¸ì´íŒì •: ${jawText}`;
		  const line3 = `ì–¼êµ´ ê¸°ìš¸ê¸°: ${headTiltText}`;

		  ctx.fillText(line1, boxX + pad, boxY + 40);
		  ctx.fillText(line2, boxX + pad, boxY + 64);
		  ctx.fillText(line3, boxX + pad, boxY + 88);

		  // 4) íŒŒì¼ ì €ì¥
		  const ts = new Date().toISOString().replace(/[:.]/g, '-');
		  const link = document.createElement('a');
		  link.download = `mm-snapshot_${ts}.png`;
		  link.href = snapCanvas.toDataURL('image/png');
		  link.click();
		}
		
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        window.addEventListener('load', () => {
            initializeFaceMesh();
        });
    </script>
</body>
</html>